--- a/drivers/net/wireless/ath/ath11k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
@@ -781,7 +781,7 @@ int ath11k_peer_rx_tid_setup(struct ath1
 	else
 		hw_desc_sz = ath11k_hal_reo_qdesc_size(DP_BA_WIN_SZ_MAX, tid);
 
-	vaddr = kzalloc(hw_desc_sz + HAL_LINK_DESC_ALIGN - 1, GFP_KERNEL);
+	vaddr = kzalloc(hw_desc_sz + HAL_LINK_DESC_ALIGN - 1, GFP_ATOMIC);
 	if (!vaddr) {
 		spin_unlock_bh(&ab->base_lock);
 		return -ENOMEM;
@@ -1216,11 +1216,9 @@ struct htt_ppdu_stats_info *ath11k_dp_ht
 {
 	struct htt_ppdu_stats_info *ppdu_info = NULL;
 
-	spin_lock_bh(&ar->data_lock);
 	if (!list_empty(&ar->ppdu_stats_info)) {
 		list_for_each_entry(ppdu_info, &ar->ppdu_stats_info, list) {
 			if (ppdu_info && ppdu_info->ppdu_id == ppdu_id) {
-				spin_unlock_bh(&ar->data_lock);
 				return ppdu_info;
 			}
 		}
@@ -1234,16 +1232,13 @@ struct htt_ppdu_stats_info *ath11k_dp_ht
 			kfree(ppdu_info);
 		}
 	}
-	spin_unlock_bh(&ar->data_lock);
 
-	ppdu_info = kzalloc(sizeof(*ppdu_info), GFP_KERNEL);
+	ppdu_info = kzalloc(sizeof(*ppdu_info), GFP_ATOMIC);
 	if (!ppdu_info)
 		return NULL;
 
-	spin_lock_bh(&ar->data_lock);
 	list_add_tail(&ppdu_info->list, &ar->ppdu_stats_info);
 	ar->ppdu_stat_list_depth++;
-	spin_unlock_bh(&ar->data_lock);
 
 	return ppdu_info;
 }
@@ -1275,8 +1270,10 @@ static int ath11k_htt_pull_ppdu_stats(st
 		ath11k_htt_ppdu_pktlog_process(ar, (u8 *)skb->data, skb->len);
 	}
 
+	spin_lock_bh(&ar->data_lock);
 	ppdu_info = ath11k_dp_htt_get_ppdu_desc(ar, ppdu_id);
 	if (!ppdu_info) {
+		spin_unlock_bh(&ar->data_lock);
 		ret = -EINVAL;
 		goto exit;
 	}
@@ -1286,10 +1283,12 @@ static int ath11k_htt_pull_ppdu_stats(st
 				     ath11k_htt_tlv_ppdu_stats_parse,
 				     (void *)ppdu_info);
 	if (ret) {
+		spin_unlock_bh(&ar->data_lock);
 		ath11k_warn(ab, "Failed to parse tlv %d\n", ret);
 		goto exit;
 	}
 
+	spin_unlock_bh(&ar->data_lock);
 exit:
 	rcu_read_unlock();
 
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -2306,22 +2306,28 @@ static int ath11k_clear_peer_keys(struct
 	int ret;
 	int i;
 	u32 flags = 0;
+	struct ieee80211_key_conf *keys[WMI_MAX_KEY_INDEX + 1];
 
 	lockdep_assert_held(&ar->conf_mutex);
 
 	spin_lock_bh(&ab->base_lock);
 	peer = ath11k_peer_find(ab, arvif->vdev_id, addr);
-	spin_unlock_bh(&ab->base_lock);
-
-	if (!peer)
+	if (!peer) {
+		spin_unlock_bh(&ab->base_lock);
 		return -ENOENT;
+	}
+	for (i = 0; i < ARRAY_SIZE(keys); i++) {
+		keys[i]= peer->keys[i];
+		peer->keys[i]= NULL;
+	}
+	spin_unlock_bh(&ab->base_lock);
 
-	for (i = 0; i < ARRAY_SIZE(peer->keys); i++) {
-		if (!peer->keys[i])
+	for (i = 0; i < ARRAY_SIZE(keys); i++) {
+		if (!keys[i])
 			continue;
 
 		/* key flags are not required to delete the key */
-		ret = ath11k_install_key(arvif, peer->keys[i],
+		ret = ath11k_install_key(arvif, keys[i],
 					 DISABLE_KEY, addr, flags);
 		if (ret < 0 && first_errno == 0)
 			first_errno = ret;
@@ -2329,10 +2335,6 @@ static int ath11k_clear_peer_keys(struct
 		if (ret < 0)
 			ath11k_warn(ab, "failed to remove peer key %d: %d\n",
 				    i, ret);
-
-		spin_lock_bh(&ab->base_lock);
-		peer->keys[i] = NULL;
-		spin_unlock_bh(&ab->base_lock);
 	}
 
 	return first_errno;
