--- a/configure.ac
+++ b/configure.ac
@@ -89,6 +89,12 @@ AC_ARG_ENABLE(
 )
 
 AC_ARG_ENABLE(
+	[dca],
+	[AS_HELP_STRING([--enable-dca], [Enable Data Channel Acceleration support for OpenVPN @<:@default=no@:>@])],
+	,
+	[enable_dca="no"]
+)
+AC_ARG_ENABLE(
 	[x509-alt-username],
 	[AS_HELP_STRING([--enable-x509-alt-username], [enable the --x509-username-field feature @<:@default=no@:>@])],
 	,
@@ -1000,6 +1006,10 @@ if test "${enable_ssl}" = "yes"; then
 	AC_DEFINE([ENABLE_SSL], [1], [Enable ssl library])
 fi
 
+if test "${enable_dca}" = "yes"; then
+	AC_DEFINE([ENABLE_DCA], [1], [Enable data channel acceleration])
+fi
+
 if test "${enable_crypto}" = "yes"; then
 	test "${have_crypto_crypto}" != "yes" && AC_MSG_ERROR([${with_crypto_library} crypto is required but missing])
 	test "${enable_crypto_ofb_cfb}" = "yes" && AC_DEFINE([ENABLE_OFB_CFB_MODE], [1], [Enable OFB and CFB cipher modes])
--- a/src/openvpn/Makefile.am
+++ b/src/openvpn/Makefile.am
@@ -20,7 +20,10 @@ EXTRA_DIST = \
 
 INCLUDES = \
 	-I$(top_srcdir)/include \
-	-I$(top_srcdir)/src/compat
+	-I$(top_srcdir)/src/compat \
+	-I$(STAGING_DIR)/usr/include/qca-nss-clients \
+	-I$(STAGING_DIR)/usr/include/qca-nss-drv \
+	-I$(STAGING_DIR)/usr/include/qca-nss-crypto-converge
 
 AM_CFLAGS = \
 	$(TAP_CFLAGS) \
@@ -111,7 +114,8 @@ openvpn_SOURCES = \
 	syshead.h \
 	tun.c tun.h \
 	win32.h win32_wfp.h win32.c \
-	cryptoapi.h cryptoapi.c
+	cryptoapi.h cryptoapi.c dca.h dca.c \
+	dca_crypto.c dca_route.c
 openvpn_LDADD = \
 	$(top_builddir)/src/compat/libcompat.la \
 	$(SOCKETS_LIBS) \
--- a/src/openvpn/crypto.c
+++ b/src/openvpn/crypto.c
@@ -485,7 +485,20 @@ init_key_ctx (struct key_ctx *ctx, struc
 	      const char *prefix)
 {
   struct gc_arena gc = gc_new ();
+#ifdef ENABLE_DCA
+  void *dca_crypto_ctx = ctx->dca_crypto_ctx;
+
+  if (!dca_crypto_ctx_init(ctx, key, kt, enc))
+      dmsg (D_DCA_INFO, "Successfully Initialized data path crypto Ctx\n");
+  else
+      dmsg (D_DCA_INFO, "Couldn't Initialized data path crypto Ctx\n");
+#endif
+
   CLEAR (*ctx);
+#ifdef ENABLE_DCA
+  ctx->dca_crypto_ctx = dca_crypto_ctx;
+#endif
+
   if (kt->cipher && kt->cipher_length > 0)
     {
 
--- a/src/openvpn/crypto.h
+++ b/src/openvpn/crypto.h
@@ -140,6 +140,9 @@ struct key_ctx
 {
   cipher_ctx_t *cipher;      	/**< Generic cipher %context. */
   hmac_ctx_t *hmac;               /**< Generic HMAC %context. */
+#ifdef ENABLE_DCA
+  void *dca_crypto_ctx;
+#endif
 };
 
 #define KEY_DIRECTION_BIDIRECTIONAL 0 /* same keys for both directions */
--- a/src/openvpn/forward.c
+++ b/src/openvpn/forward.c
@@ -46,6 +46,9 @@
 #include "occ-inline.h"
 #include "ping-inline.h"
 #include "mstats.h"
+#ifdef ENABLE_DCA
+#include "dca.h"
+#endif
 
 counter_type link_read_bytes_global;  /* GLOBAL */
 counter_type link_write_bytes_global; /* GLOBAL */
@@ -442,6 +445,17 @@ encrypt_sign (struct context *c, bool co
   if (c->c2.context_auth != CAS_SUCCEEDED)
     c->c2.buf.len = 0;
 #endif
+#ifdef ENABLE_DCA
+  /* Below changes are to handle data packet offload support */
+  if (c->c2.buf.len && c->c2.dca_ctx)
+    {
+      if (!dca_pkt_offload(c, DCA_PKT_OFFLOAD_ENCAP))
+        dmsg(D_DCA_ERRORS, "DCA: Packet (Encap) offload Failed! Dropping packet.");
+
+      c->c2.buf.len = 0;
+      return;
+    }
+#endif
 
   if (comp_frag)
     {
@@ -743,6 +757,21 @@ process_incoming_link (struct context *c
 
   if (c->c2.buf.len > 0)
     {
+#ifdef ENABLE_DCA
+  /* Below changes are to handle data packet offload support */
+      if (c->c2.dca_ctx)
+        {
+          int ret;
+
+          ret = dca_pkt_offload(c, DCA_PKT_OFFLOAD_DECAP);
+          if (ret == DCA_PKT_OFFLOAD_RETURN_SUCCESS)
+            {
+              dmsg(D_DCA_INFO, "DCA: Packet (Decap) offloaded.");
+              c->c2.buf.len = 0;
+              return;
+            }
+        }
+#endif
       c->c2.link_read_bytes += c->c2.buf.len;
       link_read_bytes_global += c->c2.buf.len;
 #ifdef ENABLE_MEMSTATS
@@ -1415,6 +1444,11 @@ pre_select (struct context *c)
   check_send_occ_msg (c);
 #endif
 
+#ifdef ENABLE_DCA
+  if (c->c2.dca_ctx)
+    dca_stats_update(c, DCA_APP_MODE_CLIENT);
+#endif
+
 #ifdef ENABLE_FRAGMENT
   /* Should we deliver a datagram fragment to remote? */
   check_fragment (c);
@@ -1444,6 +1478,9 @@ io_wait_dowork (struct context *c, const
 #ifdef ENABLE_MANAGEMENT
   static int management_shift = 6; /* depends on MANAGEMENT_READ and MANAGEMENT_WRITE */
 #endif
+#ifdef ENABLE_DCA
+  static int dca_shift = 8; /* depends on DCA_SOCKET_READ */
+#endif
 
   /*
    * Decide what kind of events we want to wait for.
@@ -1538,6 +1575,9 @@ io_wait_dowork (struct context *c, const
     management_socket_set (management, c->c2.event_set, (void*)&management_shift, NULL);
 #endif
 
+#ifdef ENABLE_DCA
+  dca_socket_set (c->c2.event_set, EVENT_READ, (void*)&dca_shift);
+#endif
   /*
    * Possible scenarios:
    *  (1) tcp/udp port has data available to read
@@ -1612,6 +1652,11 @@ process_io (struct context *c)
     }
 #endif
 
+#ifdef ENABLE_DCA
+  if (c->c2.dca_ctx && (status & DCA_SOCKET_READ))
+    dca_recv(c);
+#endif
+
   /* TCP/UDP port ready to accept write */
   if (status & SOCKET_WRITE)
     {
--- a/src/openvpn/init.c
+++ b/src/openvpn/init.c
@@ -1746,7 +1746,10 @@ do_up (struct context *c, bool pulled_op
 #if P2MP
 	  save_pulled_options_digest (c, &c->c2.pulled_options_digest);
 #endif
-
+#ifdef ENABLE_DCA
+      if (c->options.enable_dca)
+        dca_tun_up(c);
+#endif
 	  /* if --route-delay was specified, start timer */
 	  if (c->options.route_delay_defined)
 	    {
@@ -3569,6 +3572,12 @@ init_instance (struct context *c, const
     pf_init_context (c);
 #endif
 
+#ifdef ENABLE_DCA
+  /* Initialize Data Plane */
+  if (options->enable_dca && (c->mode == CM_P2P || c->mode == CM_CHILD_UDP))
+    dca_tun_alloc(c);
+#endif
+
   /* Check for signals */
   if (IS_SIG (c))
     goto sig;
@@ -3598,6 +3607,19 @@ close_instance (struct context *c)
       {
 	/* if xinetd/inetd mode, don't allow restart */
 	do_close_check_if_restart_permitted (c);
+#ifdef ENABLE_DCA
+        if (c->c2.dca_ctx)
+          {
+            if (c->mode == CM_P2P)
+              {
+                dca_tun_down(c);
+                dca_tun_free(c);
+              }
+          }
+
+        if ((c->mode == CM_TOP) || (c->mode == CM_P2P))
+          dca_uninit(c);
+#endif
 
 #ifdef ENABLE_LZO
 	if (lzo_defined (&c->c2.lzo_compwork))
--- a/src/openvpn/mudp.c
+++ b/src/openvpn/mudp.c
@@ -143,6 +143,10 @@ multi_process_io_udp (struct multi_conte
     strcat (buf, "TR/");
   else if (status & TUN_WRITE)
     strcat (buf, "TW/");
+#ifdef ENABLE_DCA
+  else if (status & DCA_SOCKET_READ)
+    strcat (buf, "DR/");
+#endif
   printf ("IO %s\n", buf);
 #endif
 
@@ -154,6 +158,11 @@ multi_process_io_udp (struct multi_conte
     }
 #endif
 
+#ifdef ENABLE_DCA
+  if (status & DCA_SOCKET_READ)
+    dca_recv(m->top);
+#endif
+
   /* UDP port ready to accept write */
   if (status & SOCKET_WRITE)
     {
@@ -239,6 +248,10 @@ tunnel_server_udp_single_threaded (struc
 
   /* finished with initialization */
   initialization_sequence_completed (top, ISC_SERVER); /* --mode server --proto udp */
+#ifdef ENABLE_DCA
+    if (top->options.enable_dca)
+      dca_init(top);
+#endif
 
   /* per-packet event loop */
   while (true)
--- a/src/openvpn/multi.c
+++ b/src/openvpn/multi.c
@@ -43,6 +43,9 @@
 
 #include "forward-inline.h"
 #include "pf-inline.h"
+#ifdef ENABLE_DCA
+#include "dca.h"
+#endif
 
 /*#define MULTI_DEBUG_EVENT_LOOP*/
 
@@ -171,6 +174,9 @@ multi_reap_range (const struct multi_con
 	  dmsg (D_MULTI_DEBUG, "MULTI: REAP DEL %s",
 	       mroute_addr_print (&r->addr, &gc));
 	  learn_address_script (m, NULL, "delete", &r->addr);
+#ifdef ENABLE_DCA
+	  dca_route_del(r);
+#endif
 	  multi_route_del (r);
 	  hash_iterator_delete_element (&hi);
 	}
@@ -572,6 +578,14 @@ multi_close_instance (struct multi_conte
   set_cc_config (mi, NULL);
 #endif
 
+#ifdef ENABLE_DCA
+  if (mi->context.c2.dca_ctx)
+    {
+      dca_tun_down(&mi->context);
+      dca_tun_free(&mi->context);
+    }
+#endif
+
   multi_client_disconnect_script (m, mi);
 
   if (mi->did_open_context)
@@ -651,6 +665,7 @@ multi_create_instance (struct multi_cont
 
   perf_push (PERF_MULTI_CREATE_INSTANCE);
 
+  msg (M_INFO, "MULTI: multi_create_instance called");
   msg (D_MULTI_MEDIUM, "MULTI: multi_create_instance called");
 
   ALLOC_OBJ_CLEAR (mi, struct multi_instance);
@@ -970,12 +985,11 @@ multi_learn_addr (struct multi_context *
 	      owner = mi;
 	      multi_instance_inc_refcount (mi);
 	      route_quota_inc (mi);
-
 	      /* add new route */
 	      hash_add_fast (m->vhash, bucket, &newroute->addr, hv, newroute);
 	    }
 	}
-      
+
       msg (D_MULTI_LOW, "MULTI: Learn%s: %s -> %s",
 	   learn_succeeded ? "" : " FAILED",
 	   mroute_addr_print (&newroute->addr, &gc),
@@ -986,7 +1000,6 @@ multi_learn_addr (struct multi_context *
 
       gc_free (&gc);
     }
-
   return owner;
 }
 
@@ -1041,7 +1054,12 @@ multi_get_instance_by_virtual_addr (stru
 	    }
 	}
     }
-  
+
+#ifdef ENABLE_DCA
+  if (ret)
+    dca_route_add(route);
+#endif
+
 #ifdef ENABLE_DEBUG
   if (check_debug_level (D_MULTI_DEBUG))
     {
@@ -1880,7 +1898,10 @@ multi_connection_established (struct mul
 
       /* set flag so we don't get called again */
       mi->connection_established_flag = true;
-
+#ifdef ENABLE_DCA
+      if (mi->context.c2.dca_ctx)
+        dca_tun_up(&mi->context);
+#endif
       /* increment number of current authenticated clients */
       ++m->n_clients;
       update_mstat_n_clients(m->n_clients);
@@ -2568,6 +2589,13 @@ stale_route_check_trigger (struct multi_
 void
 multi_process_per_second_timers_dowork (struct multi_context *m)
 {
+#ifdef ENABLE_DCA
+  if (m->top.options.enable_dca)
+    {
+      dca_stats_update(m, DCA_APP_MODE_SERVER);
+      dca_routes_update(m);
+    }
+#endif
   /* possibly reap instances/routes in vhash */
   multi_reap_process (m);
 
--- a/src/openvpn/openvpn.c
+++ b/src/openvpn/openvpn.c
@@ -66,6 +66,11 @@ tunnel_point_to_point (struct context *c
   /* set point-to-point mode */
   c->mode = CM_P2P;
 
+#ifdef ENABLE_DCA
+  if (c->options.enable_dca)
+    dca_init(c);
+#endif
+
   /* initialize tunnel instance */
   init_instance_handle_signals (c, c->es, CC_HARD_USR1_TO_HUP);
   if (IS_SIG (c))
--- a/src/openvpn/openvpn.h
+++ b/src/openvpn/openvpn.h
@@ -247,6 +247,9 @@ struct context_2
 #  define MANAGEMENT_READ  (1<<6)
 #  define MANAGEMENT_WRITE (1<<7)
 # endif
+# ifdef ENABLE_DCA
+#  define DCA_SOCKET_READ  (1<<8)
+#endif
 
   unsigned int event_set_status;
 
@@ -491,6 +494,9 @@ struct context_2
 #ifdef MANAGEMENT_DEF_AUTH
   struct man_def_auth_context mda_context;
 #endif
+#ifdef ENABLE_DCA
+  void *dca_ctx;
+#endif
 };
 
 
--- a/src/openvpn/options.c
+++ b/src/openvpn/options.c
@@ -757,6 +757,9 @@ static const char usage_message[] =
 #ifdef ENABLE_DEBUG
   "--show-gateway : Show info about default gateway.\n"
 #endif
+#ifdef ENABLE_DCA
+  "--enable-dca : Enable data channel acceleration (dca).\n"
+#endif
  ;
 
 #endif /* !ENABLE_SMALL */
@@ -878,6 +881,9 @@ init_options (struct options *o, const b
   }
 #endif /* WIN32 */
 #endif /* P2MP_SERVER */
+#ifdef ENABLE_DCA
+  o->enable_dca = false;
+#endif
   o->allow_recursive_routing = false;
 }
 
@@ -1687,6 +1693,9 @@ show_settings (const struct options *o)
   SHOW_BOOL (block_outside_dns);
   show_tuntap_options (&o->tuntap_options);
 #endif
+#ifdef ENABLE_DCA
+  SHOW_BOOL (enable_dca);
+#endif
 #endif
 }
 
@@ -2374,6 +2383,10 @@ options_postprocess_verify_ce (const str
   if (options->auth_user_pass_file && !options->pull)
     msg (M_USAGE, "--auth-user-pass requires --pull");
 #endif
+#ifdef ENABLE_DCA
+  if (options->enable_dca)
+    dca_validate_options(options, ce);
+#endif
 
   uninit_options (&defaults);
 }
@@ -7142,6 +7155,13 @@ add_option (struct options *options,
       VERIFY_PERMISSION (OPT_P_GENERAL);
       options->allow_recursive_routing = true;
     }
+#ifdef ENABLE_DCA
+  else if (streq (p[0], "enable-dca") && !p[1])
+    {
+      VERIFY_PERMISSION (OPT_P_GENERAL);
+      options->enable_dca = true;
+    }
+#endif
   else
     {
       int i;
--- a/src/openvpn/options.h
+++ b/src/openvpn/options.h
@@ -602,6 +602,9 @@ struct options
   /* Useful when packets sent by openvpn itself are not subject
      to the routing tables that would move packets into the tunnel. */
   bool allow_recursive_routing;
+#ifdef ENABLE_DCA
+  bool enable_dca;
+#endif
 };
 
 #define streq(x, y) (!strcmp((x), (y)))
--- a/src/openvpn/ssl.c
+++ b/src/openvpn/ssl.c
@@ -752,10 +752,17 @@ is_hard_reset (int op, int key_method)
 static void
 key_state_init (struct tls_session *session, struct key_state *ks)
 {
+#ifdef ENABLE_DCA
+  void *dca_crypto_ctx = ks->key.encrypt.dca_crypto_ctx;
+#endif
   update_time ();
 
   CLEAR (*ks);
 
+#ifdef ENABLE_DCA
+  ks->key.encrypt.dca_crypto_ctx = dca_crypto_ctx;
+  ks->key.decrypt.dca_crypto_ctx = dca_crypto_ctx;
+#endif
   /*
    * Build TLS object that reads/writes ciphertext
    * to/from memory BIOs.
@@ -827,6 +834,12 @@ key_state_init (struct tls_session *sess
 static void
 key_state_free (struct key_state *ks, bool clear)
 {
+#ifdef ENABLE_DCA
+  void *dca_crypto_ctx = ks->key.encrypt.dca_crypto_ctx;
+
+  if (dca_crypto_ctx)
+    dca_crypto_key_del(ks);
+#endif
   ks->state = S_UNDEF;
 
   key_state_ssl_free(&ks->ks_ssl);
@@ -863,6 +876,10 @@ key_state_free (struct key_state *ks, bo
 
   if (clear)
     CLEAR (*ks);
+#ifdef ENABLE_DCA
+  ks->key.encrypt.dca_crypto_ctx = dca_crypto_ctx;
+  ks->key.decrypt.dca_crypto_ctx = dca_crypto_ctx;
+#endif
 }
 
 /** @} name Functions for initialization and cleanup of key_state structures */
@@ -902,11 +919,24 @@ static void
 tls_session_init (struct tls_multi *multi, struct tls_session *session)
 {
   struct gc_arena gc = gc_new ();
+#ifdef ENABLE_DCA
+  void *dca_crypto_ctx = session->key[KS_PRIMARY].key.encrypt.dca_crypto_ctx;
+  int j;
+#endif
 
   dmsg (D_TLS_DEBUG, "TLS: tls_session_init: entry");
 
   CLEAR (*session);
 
+#ifdef ENABLE_DCA
+  for (j = 0; j < KS_SIZE; j++)
+    {
+      struct key_state *ks = &session->key[j];
+      ks->key.encrypt.dca_crypto_ctx = dca_crypto_ctx;
+      ks->key.decrypt.dca_crypto_ctx = dca_crypto_ctx;
+    }
+#endif
+
   /* Set options data to point to parent's option structure */
   session->opt = &multi->opt;
   
@@ -991,7 +1021,7 @@ tls_session_free (struct tls_session *se
 static void
 move_session (struct tls_multi* multi, int dest, int src, bool reinit_src)
 {
-  msg (D_TLS_DEBUG_LOW, "TLS: move_session: dest=%s src=%s reinit_src=%d",
+  msg (M_INFO, "TLS: move_session: dest=%s src=%s reinit_src=%d",
        session_index_name(dest),
        session_index_name(src),
        reinit_src);
@@ -1078,6 +1108,7 @@ tls_multi_init (struct tls_options *tls_
 
   ALLOC_OBJ_CLEAR (ret, struct tls_multi);
 
+
   /* get command line derived options */
   ret->opt = *tls_options;
 
@@ -2376,6 +2407,14 @@ tls_process (struct tls_multi *multi,
 		    print_details (&ks->ks_ssl, "Control Channel:");
 		  state_change = true;
 		  ks->state = S_ACTIVE;
+#ifdef ENABLE_DCA
+                  if (ks->key.encrypt.dca_crypto_ctx)
+                    if (dca_crypto_key_add(ks))
+                      {
+		        dmsg (D_DCA_ERRORS, "DCA Error: Couldn't add key, deleting tunnel");
+		        goto error;
+		      }
+#endif
 		  INCR_SUCCESS;
 
 		  /* Set outgoing address for data channel packets */
--- a/src/openvpn/errlevel.h
+++ b/src/openvpn/errlevel.h
@@ -69,6 +69,7 @@
 #define D_PID_PERSIST        LOGLEV(1, 12, M_NONFATAL)   /* show packet_id persist errors */
 #define D_FRAG_ERRORS        LOGLEV(1, 13, M_NONFATAL)   /* show fragmentation errors */
 #define D_ALIGN_ERRORS       LOGLEV(1, 14, M_NONFATAL)   /* show bad struct alignments */
+#define D_DCA_ERRORS         LOGLEV(1, 15, M_NONFATAL)   /* show errors in DCA */
 
 #define D_HANDSHAKE          LOGLEV(2, 20, 0)        /* show data & control channel handshakes */
 #define D_CLOSE              LOGLEV(2, 22, 0)        /* show socket and TUN/TAP close */
@@ -92,6 +93,7 @@
 #define D_OSBUF              LOGLEV(3, 43, 0)        /* show socket/tun/tap buffer sizes */
 #define D_PS_PROXY           LOGLEV(3, 44, 0)        /* messages related to --port-share option */
 #define D_PF_INFO            LOGLEV(3, 45, 0)        /* packet filter informational messages */
+#define D_DCA_INFO           LOGLEV(3, 0, 0)        /* dca informational messages */
 
 #define D_SHOW_PARMS         LOGLEV(4, 50, 0)        /* show all parameters on program initiation */
 #define D_SHOW_OCC           LOGLEV(4, 51, 0)        /* show options compatibility string */
--- /dev/null
+++ b/src/openvpn/dca.c
@@ -0,0 +1,962 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#elif defined(_MSC_VER)
+#include "config-msvc.h"
+#endif
+
+#ifdef ENABLE_DCA
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <syslog.h>
+#include <errno.h>
+#include <net/if.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <getopt.h>
+#include <stdint.h>
+#include <limits.h>
+#include <arpa/inet.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+
+#include "syshead.h"
+
+#include "forward.h"
+#include "forward-inline.h"
+#include "init.h"
+#include "mss.h"
+#include "event.h"
+#include "ps.h"
+#include "common.h"
+#include "multi.h"
+
+#include "memdbg.h"
+
+#include "dca.h"
+#include "openvpn-plugin.h"
+
+#ifndef AF_OVPN
+#define AF_OVPN 41
+#endif
+
+extern counter_type link_read_bytes_global;
+extern counter_type link_write_bytes_global;
+
+/*
+ * Global DCA context
+ */
+struct dca *g_dca_ctx;
+
+/*
+ * dca_send_msg
+ */
+int
+dca_send_msg(int cmd, void *data)
+{
+  return ioctl(g_dca_ctx->dca_sock, cmd, data);
+}
+
+/*
+ * __dca_app_register_msg
+ */
+static int
+__dca_app_register_msg(struct context *c)
+{
+  struct nss_ovpn_sk_app_inst app;
+  int err;
+  char *tun_dev_name;
+
+  if (!c->c1.tuntap)
+    {
+      msg(D_DCA_INFO, "DCA: TUN/TAP is not initialized");
+      return -1;
+    }
+
+  tun_dev_name = c->c1.tuntap->actual_name;
+  msg(D_DCA_INFO, "DCA: Registering app [%d], tun dev=%s", g_dca_ctx->pid,
+       tun_dev_name);
+  /*
+   * Init the message structure
+   */
+  strcpy(app.tun_dev, tun_dev_name);
+  app.pid = g_dca_ctx->pid;
+  if (c->mode == CM_P2P)
+    app.app_mode = NSS_OVPN_SK_APP_MODE_CLIENT;
+  else
+    app.app_mode = NSS_OVPN_SK_APP_MODE_SERVER;
+
+  return dca_send_msg(NSS_OVPN_SK_SIOC_APP_REG, &app);
+}
+
+/*
+ * __dca_app_unregister_msg
+ */
+static int
+__dca_app_unregister_msg()
+{
+  struct nss_ovpn_sk_app_inst app;
+
+  /*
+   * Init the message structure
+   */
+  app.pid = g_dca_ctx->pid;
+
+  return dca_send_msg(NSS_OVPN_SK_SIOC_APP_DEREG, &app);
+}
+
+/*
+ * __dca_tun_add_msg
+ */
+static int
+__dca_tun_add_msg(struct nss_ovpn_sk_tunnel *tun)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_TUN_ADD, tun);
+}
+
+/*
+ * __dca_tun_del_msg
+ */
+static int
+__dca_tun_del_msg(int tunnel_id)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_TUN_DEL, &tunnel_id);
+}
+
+/*
+ * __dca_tun_stats_get_msg
+ */
+static int
+__dca_tun_stats_get_msg(struct nss_ovpn_sk_tun_stats *stats)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_STATS_GET, stats);
+}
+
+/*
+ * __dca_tun_find_by_id
+ */
+static struct dca_tun *
+__dca_tun_find_by_id(unsigned int tun_id)
+{
+  struct dca_tun *tun;
+  struct dca_tun_db *temp;
+
+  if (!g_dca_ctx || !g_dca_ctx->tun_db)
+    {
+      msg(D_DCA_INFO, "DCA: Tunnel database is empty");
+      return NULL;
+    }
+
+  temp = g_dca_ctx->tun_db;
+  while (temp)
+    {
+      if (temp->tun.tun.ovpn.tunnel_id == tun_id)
+          return &temp->tun;
+
+      temp = temp->next;
+    }
+
+  return NULL;
+}
+
+/*
+ * __dca_tun_alloc
+ */
+static struct dca_tun *
+__dca_tun_alloc(void)
+{
+  struct dca_tun *tun;
+  struct dca_tun_db *tun_db;
+  struct dca_tun_db *temp;
+
+  tun_db = calloc(1, sizeof(struct dca_tun_db));
+  if (!tun_db)
+    {
+      msg(D_DCA_ERRORS, "DCA: Memory allocation for tun_db failed");
+      return NULL;
+    }
+
+  if (!g_dca_ctx->tun_db)
+    {
+      g_dca_ctx->tun_db = tun_db;
+      tun = &tun_db->tun;
+      return tun;
+    }
+
+  temp = g_dca_ctx->tun_db;
+  while (temp->next)
+    temp = temp->next;
+
+  temp->next = tun_db;
+  tun_db->prev = temp;
+
+  tun = &tun_db->tun;
+  return tun;
+}
+
+/*
+ * __dca_tun_free
+ */
+static int
+__dca_tun_free(struct dca_tun *tun)
+{
+  struct dca_tun_db *temp;
+
+  if (!g_dca_ctx || !g_dca_ctx->tun_db)
+    {
+      msg(D_DCA_INFO, "DCA: Tunnel database is empty");
+      return -1;
+    }
+
+  temp = g_dca_ctx->tun_db;
+  while (temp && (&temp->tun != tun))
+      temp = temp->next;
+
+  if (!temp)
+    {
+      msg(D_DCA_INFO, "DCA: Couldn't find the tunnel in database");
+      return -1;
+    }
+
+  if (temp->prev)
+    temp->prev->next = temp->next;
+
+  if (temp->next)
+    temp->next->prev = temp->prev;
+
+  if (temp == g_dca_ctx->tun_db) /* If the tunnel is in 1st slot */
+    g_dca_ctx->tun_db = temp->next;
+
+  free(temp);
+  return 0;
+}
+
+/*
+ * dca_validate_options
+ */
+void
+dca_validate_options(const struct options *options, const struct connection_entry *ce)
+{
+  struct options defaults;
+  int dev;
+  bool pull = false;
+  bool packet_id_long_form;
+
+  /*
+   * DCA supports only TUN mode.
+   */
+  dev = dev_type_enum(options->dev, options->dev_type);
+  if (dev != DEV_TYPE_TUN)
+    msg (M_USAGE, "Only --dev tun mode can be used with --enable-dca");
+
+  /*
+   * DCA supports only UDP Encapsulation.
+   */
+  if (!proto_is_udp(ce->proto))
+    msg (M_USAGE, "Only --proto udp can be used with --enable-dca");
+
+  /*
+   * DCA does not support OpenVPN fragmentation.
+   */
+#ifdef ENABLE_FRAGMENT
+  if (ce->fragment)
+    msg (M_USAGE, "--fragment cannot be used with --enable-dca");
+#endif
+
+  /*
+   * DCA does not support Long Packet ID format.
+   */
+#ifdef ENABLE_CRYPTO
+  if (options->shared_secret_file)
+    msg (M_USAGE, "--static cannot be used with --enable-dca");
+
+  if (dca_alg_get(options->ciphername, options->authname) < 0)
+    msg (M_USAGE, "--cipher %s, --auth %s is not supported with --enable-dca",
+           options->ciphername, options->authname);
+#endif
+  /*
+   * DCA does not support PASSTOS.
+   */
+#if PASSTOS_CAPABILITY
+  if (options->passtos)
+    msg (M_USAGE, "--passtos cannot be used with --enable-dca");
+#endif
+  /*
+   * DCA does not support compression.
+   */
+#ifdef ENABLE_LZO
+  if (options->lzo)
+    msg (M_USAGE, "--comp-lzo cannot be used with --enable-dca");
+#endif
+}
+
+/*
+ * dca_socket_set
+ */
+void
+dca_socket_set(struct event_set *es,
+      unsigned int rwflags,
+      void *arg)
+{
+  if (!g_dca_ctx)
+    return;
+
+  event_ctl (es, g_dca_ctx->dca_sock, rwflags, arg);
+}
+
+/*
+ * dca_recv
+ *     This API is called when there are packets in DCA layer.
+ */
+void
+dca_recv(struct context *c)
+{
+  struct dca_tun *tun;
+  unsigned char *data;
+  struct iovec iov;
+  struct msghdr mesg;
+  struct cmsghdr *cmsg;
+  uint8_t pkt_info_buf[CMSG_SPACE(sizeof(struct nss_ovpn_sk_pkt_info))];
+  int ret;
+
+  if (!g_dca_ctx)
+    return;
+
+  data = malloc(DCA_MAX_PKT_SIZE);
+  if (!data)
+    return;
+
+  memset(pkt_info_buf,0, sizeof(pkt_info_buf));
+  memset(&mesg, 0, sizeof(mesg));
+  iov.iov_base = data;
+  iov.iov_len = DCA_MAX_PKT_SIZE;
+  mesg.msg_iov = &iov;
+  mesg.msg_iovlen = 1;
+  mesg.msg_namelen =  0;
+  mesg.msg_control = pkt_info_buf;
+  mesg.msg_flags = 0;
+  mesg.msg_controllen = sizeof(pkt_info_buf);
+  cmsg = CMSG_FIRSTHDR(&mesg);
+  cmsg->cmsg_len = CMSG_LEN(sizeof(struct nss_ovpn_sk_pkt_info));
+  cmsg->cmsg_level = SOL_IP;
+  cmsg->cmsg_type = IP_PKTINFO;
+
+  ret = recvmsg(g_dca_ctx->dca_sock, &mesg, MSG_DONTWAIT);
+  if (ret < 0)
+    goto exit_clean_buf;
+
+  for (cmsg = CMSG_FIRSTHDR(&mesg); cmsg; cmsg = CMSG_NXTHDR(&mesg, cmsg))
+    {
+      struct nss_ovpn_sk_pkt_info *pkt_info;
+      struct context *c1;
+
+      pkt_info = (struct nss_ovpn_sk_pkt_info *) CMSG_DATA(cmsg);
+      tun = __dca_tun_find_by_id(pkt_info->tunnel_id);
+      if (!tun)
+        {
+          msg(D_DCA_ERRORS, "DCA: Tunnel is not found");
+          goto exit_clean_buf;
+        }
+      c1 = tun->c;
+
+      if (buf_write(&c1->c2.buf, (void *)data, ret) == false)
+        {
+          msg(D_DCA_ERRORS, "DCA: buf_write failed: %p", tun);
+          goto exit_clean_buf;
+        }
+
+      /*
+       * PING packets are transmitted when the tunnel is idle.
+       * If packets are received from peer, there is no need to
+       * send PING packets.  Reset packet received timer.
+       */
+      if (c1->options.ping_rec_timeout && c1->c2.buf.len > 0)
+        event_timeout_reset(&c1->c2.ping_rec_interval);
+
+      /*
+       * Handle PING packets.
+       */
+      if (is_ping_msg(&c1->c2.buf))
+        msg(D_DCA_INFO, "DCA: Received PING packet:%p", tun);
+
+#ifdef ENABLE_OCC
+       /* Did we just receive an OCC packet? */
+       if (is_occ_msg(&c1->c2.buf))
+         process_received_occ_msg(c1);
+#endif
+       /*
+        * PING/OCC packets are only expected from OVPN client.
+        * Packet is processed above, drop the packet here
+        */
+       c1->c2.buf.len = 0;
+    }
+exit_clean_buf:
+  free(data);
+}
+
+/*
+ * dca_tun_stats_update
+ *     This API updates statistics of given tun.
+ */
+void
+dca_tun_stats_update(struct context *c, struct dca_tun *tun)
+{
+  struct nss_ovpn_sk_tun_stats stats;
+
+  if (c->c2.context_auth != CAS_SUCCEEDED)
+    return;
+
+  if (tun->state == DCA_TUN_STATE_DOWN)
+    return;
+
+  stats.tunnel_id = tun->tun.ovpn.tunnel_id;
+  if (__dca_tun_stats_get_msg(&stats))
+    return;
+
+  /*
+   * Update tunnel statistics.
+   */
+  c->c2.tun_read_bytes += stats.tun_read_bytes;
+  c->c2.tun_write_bytes += stats.tun_write_bytes;
+  c->c2.link_read_bytes += stats.link_read_bytes;
+  link_read_bytes_global += stats.link_read_bytes;
+  c->c2.link_read_bytes_auth += stats.link_read_bytes_auth;
+  c->c2.link_write_bytes     += stats.link_write_bytes;
+  link_write_bytes_global += stats.link_write_bytes;
+
+  /*
+   * Statistics are maintained by application in c->c2 context.
+   * DCA layer clears statistics after sending to application.
+   * If link_read_bytes is non-zero then packets are handled in DCA layer indicating
+   * that data channel is busy.
+   * Reset PING timer, there is no need to send PING packets.
+   */
+  if (stats.link_read_bytes)
+    {
+      if (c->options.ping_rec_timeout)
+        event_timeout_reset(&c->c2.ping_rec_interval);
+    }
+}
+
+/*
+ * dca_stats_update
+ *   This API handles updating statistics of all tunnels.
+ */
+void
+dca_stats_update(void *p, int server)
+{
+
+  if (!g_dca_ctx)
+    return;
+
+  if (!server)
+    {
+      struct context *c = p;
+      struct dca_tun *tun = c->c2.dca_ctx;
+
+      if (!tun)
+        return;
+
+      dca_tun_stats_update(c, tun);
+    }
+  else
+    {
+      struct multi_context *m = p;
+      struct hash_iterator hi;
+      struct hash_element *he;
+      struct multi_instance *mi;
+
+      /*
+       * Tunnels are maintained in Hash Table.
+       * hash_iterator* APIs are used to parse through
+       * hash table.
+       */
+      hash_iterator_init(m->iter, &hi);
+      while ((he = hash_iterator_next(&hi)))
+        {
+          struct context *c;
+          struct dca_tun *tun;
+          mi = (struct multi_instance *) he->value;
+          c = &mi->context;
+          tun = c->c2.dca_ctx;
+          if (!tun)
+            continue;
+
+          dca_tun_stats_update(c, tun);
+        }
+      hash_iterator_free(&hi);
+    }
+}
+
+/*
+ * dca_pkt_offload
+ *     This API attempts to offload packet stored in c->c2.buf.
+ *  For each packet below information is filled and sent to DCA layer:
+ *         1. Tunnel ID
+ *         2. Packet direction - Encrypt/Encap or Decrypt/Decap
+ *         3. Packet type - IPv4 or IPv6.
+ *
+ *  It can return 3 differnt values:
+ *         1. DCA_PKT_OFFLOAD_RETURN_FAILURE - Packet couldn't be offloaded.
+ *         2. DCA_PKT_OFFLOAD_RETURN_SUCCESS - Packet is offloaded Successfully.
+ *         3. DCA_PKT_OFFLOAD_RETURN_CTRL_PKT - Packet is control packet (SSL/TLS packet).
+ */
+int
+dca_pkt_offload(struct context *c, int decrypt)
+{
+  struct dca_tun *tun = c->c2.dca_ctx;
+  struct buffer *buf = &c->c2.buf;
+  struct iovec iov;
+  struct msghdr mesg;
+  struct cmsghdr *cmsg;
+  struct nss_ovpn_sk_pkt_info *pkti;
+  struct buffer ipbuf = *buf;
+  uint8_t pkt_info_buf[CMSG_SPACE(sizeof(struct nss_ovpn_sk_pkt_info))];
+  int ret;
+  int i;
+  int key_id;
+
+  if (!g_dca_ctx || !tun)
+    return DCA_PKT_OFFLOAD_RETURN_FAILURE;
+
+  if (decrypt)
+    {
+      int op;
+      uint8_t op_key = *BPTR(buf);
+
+      /* Check if data channel is up */
+      if (c->c2.context_auth != CAS_SUCCEEDED)
+        return DCA_PKT_OFFLOAD_RETURN_FAILURE;
+
+      /* Get opcode and key ID */
+      op = op_key >> P_OPCODE_SHIFT;
+      key_id = op_key & P_KEY_ID_MASK;
+
+      /*
+       * Offload only data packets
+       * Return if the packets received are not data packets.
+       */
+      if (!((op == P_DATA_V1) || (op == P_DATA_V2)))
+        {
+          /*
+           * If we get reset here, it means client which is already connected has
+           * restarted.
+           */
+          if ((op == P_CONTROL_HARD_RESET_CLIENT_V2) || (op == P_CONTROL_HARD_RESET_CLIENT_V1))
+            {
+              if (tun->state == DCA_TUN_STATE_UP)
+                {
+                  msg(D_DCA_INFO, "DCA: Client restarted, deleting tunnel in DCA layer: %p", tun);
+                  dca_tun_down(tun->c);
+                }
+            }
+          return DCA_PKT_OFFLOAD_RETURN_CTRL_PKT;
+        }
+
+      if (tun->state == DCA_TUN_STATE_DOWN)
+        {
+          msg(D_DCA_INFO, "DCA: Client re-established tunnel successfully, adding tunnel in DCA layer: %p", tun);
+          dca_tun_up(tun->c);
+        }
+    }
+
+  if (tun->state == DCA_TUN_STATE_DOWN)
+    return DCA_PKT_OFFLOAD_RETURN_FAILURE;
+
+  memset(pkt_info_buf,0, sizeof(pkt_info_buf));
+  memset(&mesg, 0, sizeof(mesg));
+  iov.iov_base = BPTR(buf);
+  iov.iov_len = BLEN(buf);
+  mesg.msg_iov = &iov;
+  mesg.msg_iovlen = 1;
+  mesg.msg_namelen =  0;
+  mesg.msg_control = pkt_info_buf;
+  mesg.msg_flags = 0;
+  mesg.msg_controllen = sizeof(pkt_info_buf);
+  cmsg = CMSG_FIRSTHDR(&mesg);
+  cmsg->cmsg_len = CMSG_LEN(sizeof(struct nss_ovpn_sk_pkt_info));
+  cmsg->cmsg_level = SOL_IP;
+  cmsg->cmsg_type = IP_PKTINFO;
+
+  pkti = (struct nss_ovpn_sk_pkt_info *) CMSG_DATA(cmsg);
+  if (decrypt)
+    {
+      pkti->flags |= NSS_OVPN_SK_PKT_INFO_FLAG_DIR_DECAP;
+      if (tun->tun.ovpn.flags & NSS_OVPN_SK_OVPN_HDR_FLAG_IPv6)
+        {
+          /* IPv6 packet. */
+          pkti->flags |= NSS_OVPN_SK_PKT_INFO_FLAG_PKT_TYPE_IPV6;
+        }
+    }
+
+  pkti->tunnel_id = tun->tun.ovpn.tunnel_id;
+
+  ret = sendmsg(g_dca_ctx->dca_sock, &mesg, 0);
+  if (ret < 0)
+    {
+      msg(D_DCA_ERRORS, "DCA: Packet offload failed:%p", tun);
+    }
+
+  return DCA_PKT_OFFLOAD_RETURN_SUCCESS;
+}
+
+/*
+ * dca_tun_up
+ *     This API is called when tunnel is negotiated successfully.  It will
+ *     extract necessary parameters from c and adds tunnel in DCA layer.
+ */
+void
+dca_tun_up(struct context *c)
+{
+  struct dca_tun *tun = c->c2.dca_ctx;
+  struct gc_arena gc = gc_new();
+  struct tls_multi *multi = c->c2.tls_multi;
+  struct link_socket_info *info = get_link_socket_info(c);
+  struct openvpn_sockaddr *addr = &info->lsa->actual.dest;
+  const struct link_socket_actual *act = c->c2.to_link_addr;
+  struct push_entry *e = c->options.push_list.head;
+
+  if (!g_dca_ctx || !tun)
+    {
+      gc_free(&gc);
+      return;
+    }
+
+  if (c->mode == CM_P2P)
+    {
+      if (__dca_app_register_msg(c))
+        {
+          msg(D_DCA_INFO, "DCA: Failed to register app:%p", tun);
+          close(g_dca_ctx->dca_sock);
+          free(g_dca_ctx);
+          g_dca_ctx = NULL;
+          gc_free(&gc);
+          return;
+        }
+    }
+
+  /*
+   *  Copy Tunnel end point parameters
+   */
+  switch (addr->addr.sa.sa_family)
+    {
+      case AF_INET:
+        {
+          /* Get tunnel destination port */
+          tun->tun.tun_hdr.dst_port =  addr->addr.in4.sin_port;
+          /* Get tunnel source port */
+          tun->tun.tun_hdr.src_port = htons(c->options.ce.local_port);
+          /* Get tunnel destination IP */
+          tun->tun.tun_hdr.dst_ip[0] = addr->addr.in4.sin_addr.s_addr;
+
+          /* Get tunnel source IP */
+          if (act)
+            {
+              struct openvpn_sockaddr sa;
+              CLEAR(sa);
+              sa.addr.in4.sin_family = AF_INET;
+#ifdef IP_PKTINFO
+               sa.addr.in4.sin_addr = act->pi.in4.ipi_spec_dst;
+#elif defined(IP_RECVDSTADDR)
+               sa.addr.in4.sin_addr = act->pi.in4;
+               ifname[0] = 0;
+#endif
+               tun->tun.tun_hdr.src_ip[0] = sa.addr.in4.sin_addr.s_addr;
+            }
+          else
+            {
+              /* Can't continue since tunnel source IP is not available */
+              goto err_exit;
+            }
+        }
+      break;
+
+      case AF_INET6:
+        {
+          /* Get tunnel destination port */
+          tun->tun.tun_hdr.dst_port =  addr->addr.in6.sin6_port;
+          /* Get tunnel source port */
+          tun->tun.tun_hdr.src_port = htons(c->options.ce.local_port);
+
+          /* Get tunnel destination IP */
+          memcpy(&tun->tun.tun_hdr.dst_ip[0], &addr->addr.in6.sin6_addr, sizeof(addr->addr.in6.sin6_addr));
+
+          /* Get tunnel Source IP */
+          if (act)
+            {
+               memcpy(&tun->tun.tun_hdr.src_ip[0], &act->pi.in6.ipi6_addr, sizeof(act->pi.in6.ipi6_addr));
+            }
+          else
+            {
+              /* Can't continue since tunnel source IP is not available */
+            goto err_exit;
+        }
+          tun->tun.ovpn.flags |= NSS_OVPN_SK_OVPN_HDR_FLAG_IPv6;
+        }
+      break;
+
+      default:
+          msg(D_DCA_INFO, "DCA: Incorrect address family");
+          goto err_exit;
+    }
+
+  /*
+   * Copy Crypto parameters.
+   */
+  memcpy(&tun->tun.crypto, &tun->crypto, sizeof(tun->crypto));
+  tun->tun.crypto.key_id = 0;  /* Note: When tunnel is up, key_id always starts with 0 */
+
+  /*
+   *  Check if this is V2 Data header
+   */
+  if (!multi->opt.server && multi->use_peer_id)
+    {
+      tun->tun.ovpn.flags |= NSS_OVPN_SK_OVPN_HDR_FLAG_DATA_V2;
+      tun->tun.ovpn.peer_id = multi->peer_id;
+    }
+
+  /*
+   * Check if server allows Data V2 for the client.
+   */
+  if (c->mode != CM_P2P)
+    {
+      while (e)
+        {
+          if (e->enable && strstr (e->option, "peer-id"))
+            {
+              msg(D_DCA_INFO, "DCA: Client will send V2 data packets: %s ", e->option);
+              tun->tun.ovpn.flags |= NSS_OVPN_SK_OVPN_HDR_FLAG_PEER_DATA_V2;
+              break;
+            }
+            e = e->next;
+        }
+    }
+
+  /* All Set. Send Tunnel add message */
+  if (__dca_tun_add_msg(&tun->tun))
+    {
+      msg(D_DCA_INFO, "DCA: Failed to add tunnel in DCA: %p", tun);
+      goto err_exit;
+    }
+
+    msg(D_DCA_INFO, "Tunnel add successful: tun_id = %d\n",
+           tun->tun.ovpn.tunnel_id);
+
+  /*
+   * Packets are routed in DCA as host based route.  It doesn't maintain
+   * address assigned to us (client) or address assigned by us (server).
+   * Add remote assigned IP Address as route here.
+   */
+  if (c->c2.push_ifconfig_local)
+    {
+      /* Add ipv4 route */
+      struct nss_ovpn_sk_route_info route_info;
+
+      msg(D_DCA_INFO, "DCA: Remote IPv4 Addr : %s",
+           print_in_addr_t( c->c2.push_ifconfig_local, IA_NET_ORDER, &gc));
+      route_info.tunnel_id = tun->tun.ovpn.tunnel_id;
+      route_info.ip_version = 4;
+      route_info.ip_network[0] = htonl(c->c2.push_ifconfig_local);
+      route_info.netmask_bits = 32;
+
+      if (dca_route_add_msg(&route_info))
+        msg(D_DCA_INFO, "%s:%s Failed to add route", __func__,
+           print_in_addr_t( c->c2.push_ifconfig_local, IA_NET_ORDER, &gc));
+    }
+
+  if (c->c2.push_ifconfig_ipv6_defined)
+    {
+       /* Add ipv6 route */
+      struct nss_ovpn_sk_route_info route_info;
+
+      msg(D_DCA_INFO, "DCA: Remote IPv6 Addr : %s",
+           print_in6_addr( c->c2.push_ifconfig_ipv6_remote, 0, &gc));
+
+      memcpy(&route_info.ip_network[0],
+             &c->c2.push_ifconfig_ipv6_local, sizeof(struct in6_addr));
+      route_info.ip_version = 6;
+      route_info.netmask_bits = 128;
+
+      if (dca_route_add_msg(&route_info))
+        msg(D_DCA_INFO, "%s:%s Failed to add route", __func__,
+             &c->c2.push_ifconfig_ipv6_local, sizeof(struct in6_addr));
+    }
+
+  /*
+   * Copy reference of c into tun.  This is required to update statistics later.
+   */
+  tun->c = c;
+  tun->state = DCA_TUN_STATE_UP;
+
+  gc_free(&gc);
+  return;
+
+err_exit:
+  __dca_tun_free(tun);
+  c->c2.dca_ctx = NULL;
+  gc_free(&gc);
+}
+
+/*
+ * dca_tun_down
+ */
+void
+dca_tun_down(struct context *c)
+{
+  struct dca_tun *tun = c->c2.dca_ctx;
+
+  if (!g_dca_ctx)
+    return;
+
+  if (__dca_tun_del_msg(tun->tun.ovpn.tunnel_id))
+    msg(D_DCA_ERRORS, "DCA: Tunnel delete failed:%p", tun);
+
+  tun->state = DCA_TUN_STATE_DOWN;
+}
+
+/*
+ * dca_tun_alloc
+ */
+void
+dca_tun_alloc(struct context *c)
+{
+  struct dca_tun *tun;
+  int i;
+  struct tls_multi *multi = c->c2.tls_multi;
+
+  if (!g_dca_ctx)
+    return;
+
+  tun = __dca_tun_alloc();
+  if (!tun)
+    {
+      msg(D_DCA_INFO, "DCA: Tunnel alloc failed");
+      return;
+    }
+
+  for (i = 0; i < TM_SIZE; ++i)
+    {
+      int j;
+      struct tls_session *session = &multi->session[i];
+
+      for (j = 0; j < KS_SIZE; j++)
+        {
+          struct key_state *ks = &session->key[j];
+          ks->key.encrypt.dca_crypto_ctx = (void *)tun;
+          ks->key.decrypt.dca_crypto_ctx = (void *)tun;
+        }
+    }
+  msg(D_DCA_INFO, "DCA: Tunnel alloc successful:%p", tun);
+  c->c2.dca_ctx = (void *)tun;
+}
+
+/*
+ * dca_tun_free
+ */
+void
+dca_tun_free(struct context *c)
+{
+  struct dca_tun *tun = c->c2.dca_ctx;
+
+  if (!g_dca_ctx)
+    return;
+
+  __dca_tun_free(tun);
+  c->c2.dca_ctx = NULL;
+}
+
+/*
+ * dca_init
+ */
+void
+dca_init(struct context *c)
+{
+  int i;
+  struct tls_multi *multi = c->c2.tls_multi;
+
+  g_dca_ctx = calloc(1, sizeof(*g_dca_ctx));
+  if (!g_dca_ctx)
+    {
+      msg(D_DCA_ERRORS, "DCA: Memory allocation failed.  DCA failed");
+      return;
+    }
+
+  g_dca_ctx->dca_sock = socket(AF_OVPN, SOCK_DGRAM, 0);
+  if (g_dca_ctx->dca_sock < 0)
+    {
+      msg(D_DCA_ERRORS, "DCA: Unable to create OVPN socket");
+      free(g_dca_ctx);
+      g_dca_ctx = NULL;
+      return;
+    }
+
+  g_dca_ctx->pid = getpid();
+
+  if (c->mode != CM_P2P)
+    {
+      msg(D_DCA_INFO, "DCA: mode is server");
+      /*
+       * Register application
+       * Note: Application register is done for Client mode in dca_tun_up()
+       */
+      if (__dca_app_register_msg(c))
+        {
+          msg(D_DCA_ERRORS, "DCA: Failed to register app");
+          close(g_dca_ctx->dca_sock);
+          free(g_dca_ctx);
+          g_dca_ctx = NULL;
+          return;
+        }
+    }
+  else
+    msg(D_DCA_INFO, "DCA: mode is client");
+
+  msg(D_DCA_INFO, "DCA: Application is registered successfully\n");
+}
+
+/*
+ * dca_uninit
+ */
+void
+dca_uninit(struct context *c)
+{
+  if (!g_dca_ctx)
+    return;
+
+  if (__dca_app_unregister_msg())
+    msg(D_DCA_INFO, "DCA: Failed to unregister app");
+
+  close(g_dca_ctx->dca_sock);
+  free(g_dca_ctx);
+  msg(D_DCA_INFO, "DCA: Application is deregistered successfully\n");
+}
+#else /* ifdef ENABLE_DCA */
+static void
+dummy(void)
+{
+}
+#endif /* ENABLE_DCA */
--- /dev/null
+++ b/src/openvpn/dca.h
@@ -0,0 +1,121 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/**
+ * @file
+ * Interface functions to the Data Channel Offload.
+ */
+
+#ifndef __DCA_H__
+#define __DCA_H__
+
+#include "openvpn.h"
+#include "nss_ovpn_sk.h"
+
+#define DCA_APP_MODE_CLIENT 0
+#define DCA_APP_MODE_SERVER 1
+
+#define DCA_ROUTE_ADD  0
+#define DCA_ROUTE_DEL  1
+
+#define DCA_ROUTE_TYPE_IPV4  1
+#define DCA_ROUTE_TYPE_IPV6  2
+
+#define DCA_PKT_OFFLOAD_ENCAP  0
+#define DCA_PKT_OFFLOAD_DECAP  1
+
+#define DCA_PKT_OFFLOAD_RETURN_SUCCESS   0
+#define DCA_PKT_OFFLOAD_RETURN_FAILURE  -1
+#define DCA_PKT_OFFLOAD_RETURN_CTRL_PKT -2
+
+#define DCA_CRYPTO_ALG_NAME_MAX_LEN 20
+/*
+ * Packets received from DCA are very small, PING/OCC packets are the only
+ * packet received.  PING packet is about 16 bytes and OCC packet could be
+ * more than 300 bytes, declaring max packet size as 500 bytes.
+ */
+#define DCA_MAX_PKT_SIZE  500
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
+
+enum dca_tun_state
+{
+  DCA_TUN_STATE_UP = 0,
+  DCA_TUN_STATE_DOWN = 1,
+  DCA_TUN_STATE_MAX
+};
+
+/*
+ * dca_tun
+ *    Tunnel details.
+ */
+struct dca_tun {
+    struct context *c;                        /* OpenVPN tunnel context */
+    struct nss_ovpn_sk_tunnel tun;            /* Offload tunnel details */
+    struct nss_ovpn_sk_crypto_session crypto; /* Decription crypto parameters */
+    uint32_t state;				/* Tunnel State. */
+};
+
+/*
+ * dca_tun
+ *    Tunnel details.
+ */
+struct dca_tun_db {
+    struct dca_tun tun;           /* Tunnel details */
+    struct dca_tun_db *next;   /* Next */
+    struct dca_tun_db *prev;   /* Previous */
+};
+
+/*
+ * dca_stats
+ *    DCA statistics
+ */
+struct dca_stats {
+    counter_type tun_read_bytes;        /* Tun/Tap read (packet length) bytes */
+    counter_type tun_write_bytes;       /* Tun/Tap write (packet length) bytes */
+    counter_type link_read_bytes;       /* Socket (Peer) read (packet length) bytes */
+    counter_type link_read_bytes_auth;  /* Socket (Peer) read (packet length) bytes authenticated */
+    counter_type link_write_bytes;      /* Socket (Peer) write (packet length) bytes */
+};
+
+/*
+ * dca
+ *    Contains offload state information for one tunnel.
+ *    This structure represents offload state for all VPN tunnels.
+ */
+struct dca {
+    pid_t pid;                     /* process PID */
+    int dca_sock;                  /* Data channel offload socket */
+    struct nss_ovpn_sk_tunnel tun; /* Tunnel data structure */
+    struct dca_stats stats;        /* Offload tunnel statistics */
+    struct dca_tun_db *tun_db;  /* Active Tunnels Database */
+};
+
+int dca_pkt_offload(struct context *c, int decrypt);
+int dca_crypto_ctx_init(struct key_ctx *ctx, struct key *key,
+                        const struct key_type *kt, int enc);
+void dca_tun_up(struct context *c);
+void dca_crypto_key_free(struct key_state *ks);
+int dca_crypto_key_add(struct key_state *ks);
+void dca_init(struct context *c);
+void dca_uninit(struct context *c);
+void dca_route_add(struct multi_route *r);
+void dca_route_del(struct multi_route *r);
+int dca_route_add_msg(struct nss_ovpn_sk_route_info *route_info);
+void dca_tun_alloc(struct context *c);
+void dca_tun_delete(struct context *c);
+void dca_tun_down(struct context *c);
+
+#endif  /* __DCA_H__ */
--- /dev/null
+++ b/src/openvpn/dca_crypto.c
@@ -0,0 +1,324 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#elif defined(_MSC_VER)
+#include "config-msvc.h"
+#endif
+
+#ifdef ENABLE_DCA
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <syslog.h>
+#include <errno.h>
+#include <net/if.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <getopt.h>
+#include <stdint.h>
+#include <limits.h>
+#include <arpa/inet.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+
+#include "syshead.h"
+
+#include "forward.h"
+#include "forward-inline.h"
+#include "init.h"
+#include "mss.h"
+#include "event.h"
+#include "ps.h"
+#include "common.h"
+#include "multi.h"
+
+#include "memdbg.h"
+
+#include "dca.h"
+#include "openvpn-plugin.h"
+
+extern struct dca *g_dca_ctx;
+
+/*
+ * dca_alg
+ */
+struct dca_alg {
+	char *cipher_alg;
+	char *hmac_alg;
+	int algo;
+};
+
+/*
+ * Algorithms supported in DCA layer.
+ */
+static struct dca_alg aead_alg[] = {
+	{ "aes-128-cbc",  "sha1",   NSS_OVPN_SK_ALGO_AES_CBC_SHA1_HMAC},
+	{ "aes-192-cbc",  "sha1",   NSS_OVPN_SK_ALGO_AES_CBC_SHA1_HMAC},
+	{ "aes-256-cbc",  "sha1",   NSS_OVPN_SK_ALGO_AES_CBC_SHA1_HMAC},
+	{ "aes-128-cbc",  "sha256", NSS_OVPN_SK_ALGO_AES_CBC_SHA256_HMAC},
+	{ "aes-192-cbc",  "sha256", NSS_OVPN_SK_ALGO_AES_CBC_SHA256_HMAC},
+	{ "aes-256-cbc",  "sha256", NSS_OVPN_SK_ALGO_AES_CBC_SHA256_HMAC},
+	{ "des-ede3-cbc", "sha1",   NSS_OVPN_SK_ALGO_3DES_CBC_SHA1_HMAC},
+	{ "des-ede3-cbc", "sha256", NSS_OVPN_SK_ALGO_3DES_CBC_SHA256_HMAC},
+};
+
+/*
+ * Application crypto algorithm names.
+ */
+static struct dca_alg ablk_alg[] = {
+	{ "aes-128-cbc",   NULL,    NSS_OVPN_SK_ALGO_AES_CBC_NULL_AUTH},
+	{ "aes-192-cbc",   NULL,    NSS_OVPN_SK_ALGO_AES_CBC_NULL_AUTH},
+	{ "aes-256-cbc",   NULL,    NSS_OVPN_SK_ALGO_AES_CBC_NULL_AUTH},
+	{ "des-ede3-cbc",  NULL,    NSS_OVPN_SK_ALGO_3DES_CBC_NULL_AUTH},
+};
+
+/*
+ * Application hash algorithm names.
+ */
+static struct dca_alg ahash_alg[] = {
+	{ NULL,           "sha1",   NSS_OVPN_SK_ALGO_NULL_CIPHER_SHA1_HMAC},
+	{ NULL,           "sha256", NSS_OVPN_SK_ALGO_NULL_CIPHER_SHA256_HMAC},
+};
+
+/*
+ * __dca_crypto_key_add_msg
+ */
+static int
+__dca_crypto_key_add_msg(struct nss_ovpn_sk_crypto_session *crypto_key)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_CRYPTO_KEY_ADD,  crypto_key);
+}
+
+/*
+ * __dca_crypto_key_del_msg
+ */
+static int
+__dca_crypto_key_del_msg(struct nss_ovpn_sk_crypto_session *crypto_session)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_CRYPTO_KEY_DEL, crypto_session);
+}
+
+/*
+ * dca_alg_get()
+ *	Return DCA crypto algorithm index.
+ */
+int
+dca_alg_get(const char *cipher_alg, const char *hmac_alg)
+{
+  int i;
+
+  /*
+   * AEAD mode?
+   */
+  if (cipher_alg && hmac_alg)
+    {
+      for (i = 0; i < ARRAY_SIZE(aead_alg); i++)
+        if ((strncasecmp(aead_alg[i].cipher_alg, cipher_alg, DCA_CRYPTO_ALG_NAME_MAX_LEN) == 0) &&
+            (strncasecmp(aead_alg[i].hmac_alg, hmac_alg, DCA_CRYPTO_ALG_NAME_MAX_LEN) == 0))
+              return aead_alg[i].algo;
+
+      return -1;
+    }
+
+  /*
+   * ABLK mode?
+   */
+  if (cipher_alg)
+    {
+      for (i = 0; i < ARRAY_SIZE(ablk_alg); i++)
+        if (strncasecmp(ablk_alg[i].cipher_alg, cipher_alg, DCA_CRYPTO_ALG_NAME_MAX_LEN) == 0)
+          return ablk_alg[i].algo;
+
+      return -1;
+    }
+
+  /*
+   * AHASH mode?
+   */
+  if (hmac_alg)
+    {
+      for (i = 0; i < ARRAY_SIZE(ahash_alg); i++)
+        if (strncasecmp(ahash_alg[i].hmac_alg, hmac_alg, DCA_CRYPTO_ALG_NAME_MAX_LEN) == 0)
+          return ahash_alg[i].algo;
+
+      return -1;
+    }
+
+  /*
+   * Cipher is none.
+   * Hash is none.
+   */
+  return NSS_OVPN_SK_ALGO_NULL_CIPHER_NULL_AUTH;
+}
+
+/*
+ * dca_crypto_ctx_init
+ */
+int
+dca_crypto_ctx_init(struct key_ctx *ctx, struct key *key,
+                    const struct key_type *kt, int enc)
+{
+  struct dca_tun *tun = ctx->dca_crypto_ctx;
+  struct nss_ovpn_sk_crypto_session *crypto;
+  struct nss_ovpn_sk_crypto_key *crypto_key;
+  const char *cipher_alg = NULL, *hmac_alg = NULL;
+
+  if (!g_dca_ctx || !tun)
+    return -1;
+
+  crypto = &tun->crypto;
+
+  if (enc)
+    crypto_key = &crypto->encrypt;
+  else
+    crypto_key = &crypto->decrypt;
+
+  /*
+   * Copy Cipher Key.
+   */
+  if (kt->cipher && kt->cipher_length > 0)
+    {
+      cipher_alg = cipher_kt_name(kt->cipher);
+      crypto->config.cipher_key_size = kt->cipher_length;
+      memcpy(&crypto_key->cipher_key, key->cipher, kt->cipher_length);
+      msg(D_DCA_INFO, "DCA: Cipher is '%s': %p", cipher_alg, tun);
+    }
+  else
+    {
+      crypto->config.cipher_key_size = 0;
+      msg(D_DCA_INFO, "DCA: Cipher is 'none': %p", tun);
+      /* Set the flags if there is no crypto */
+      tun->tun.ovpn.flags |= NSS_OVPN_SK_OVPN_HDR_FLAG_NO_CIPHER;
+    }
+
+  /*
+   * Copy HMAC Key.
+   */
+  if (kt->digest && kt->hmac_length > 0)
+    {
+      hmac_alg = md_kt_name(kt->digest);
+      crypto->config.hmac_key_size = kt->hmac_length;
+      memcpy(&crypto_key->hmac_key, key->hmac, kt->hmac_length);
+      msg(D_DCA_INFO, "DCA: Auth is '%s': %p", hmac_alg, tun);
+    }
+  else
+    {
+      msg(D_DCA_INFO, "DCA: Auth is 'none': %p", tun);
+      crypto->config.hmac_key_size = 0;
+      /* Set the flags if there is no crypto */
+      tun->tun.ovpn.flags |= NSS_OVPN_SK_OVPN_HDR_FLAG_NO_AUTH;
+    }
+
+  /*
+   * DCA layer support some of crypto algorithms which are validated during
+   * configuration when enable_dca is configured.
+   * dca_alg_get should return proper value.
+   */
+  crypto->config.algo = dca_alg_get(cipher_alg, hmac_alg);
+
+  return 0;
+}
+
+/*
+ * dca_crypto_key_del
+ */
+void
+dca_crypto_key_del(struct key_state *ks)
+{
+  struct key_ctx *ctx = &ks->key.encrypt;
+  struct dca_tun *tun = ctx->dca_crypto_ctx;
+  struct nss_ovpn_sk_crypto_session *crypto;
+
+  if (!ctx->cipher || !ctx->hmac || !tun)
+    return;
+
+  if (tun->state == DCA_TUN_STATE_DOWN)
+    return;
+
+  msg(D_DCA_INFO, "DCA: Deleting key for tunnel: %d, key_id = %d: %p",
+    tun->tun.ovpn.tunnel_id, ks->key_id, tun);
+
+  crypto = calloc(1, sizeof(*crypto));
+  if (!crypto)
+    {
+      msg(D_DCA_ERRORS, "DCA: Memory Allocation Failed, couldn't delete key: %p", tun);
+      return;
+    }
+
+  crypto->tunnel_id = tun->tun.ovpn.tunnel_id;
+  crypto->key_id = ks->key_id;
+
+  if (__dca_crypto_key_del_msg(crypto))
+    msg(D_DCA_ERRORS,"DCA: Crypto key delete failed : %p", tun);
+
+  free(crypto);
+}
+
+/*
+ * dca_crypto_key_add
+ */
+int
+dca_crypto_key_add(struct key_state *ks)
+{
+  int ret;
+  struct dca_tun *tun = ks->key.encrypt.dca_crypto_ctx;
+  struct nss_ovpn_sk_crypto_session *crypto;
+
+  if (!tun || !ks->key_id)
+    return 0;
+
+  if (tun->state == DCA_TUN_STATE_DOWN)
+    return 0;
+
+  msg(D_DCA_INFO, "DCA: Updating key for tunnel: %d, key_id = %d: %p",
+      tun->tun.ovpn.tunnel_id, ks->key_id, tun);
+
+  crypto = calloc(1, sizeof(*crypto));
+  if (!crypto)
+    {
+      msg(D_DCA_ERRORS, "DCA: Memory Allocation Failed, couldn't update key : %p", tun);
+      return -1;
+    }
+
+  memcpy(crypto, &tun->crypto, sizeof(tun->crypto));
+
+  crypto->tunnel_id = tun->tun.ovpn.tunnel_id;
+  crypto->key_id = ks->key_id;
+
+  ret = __dca_crypto_key_add_msg(crypto);
+  if (ret)
+    msg(D_DCA_ERRORS, "DCA: Crypto key add failed : %p", tun);
+
+  free(crypto);
+
+  return ret;
+}
+#else /* ifdef ENABLE_DCA */
+static void
+dummy(void)
+{
+}
+#endif /* ENABLE_DCA */
--- /dev/null
+++ b/src/openvpn/dca_route.c
@@ -0,0 +1,256 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#elif defined(_MSC_VER)
+#include "config-msvc.h"
+#endif
+
+#ifdef ENABLE_DCA
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <syslog.h>
+#include <errno.h>
+#include <net/if.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <getopt.h>
+#include <stdint.h>
+#include <limits.h>
+#include <arpa/inet.h>
+#include <linux/socket.h>
+#include <linux/sockios.h>
+
+#include "syshead.h"
+
+#include "forward.h"
+#include "forward-inline.h"
+#include "init.h"
+#include "mss.h"
+#include "event.h"
+#include "ps.h"
+#include "common.h"
+#include "multi.h"
+
+#include "memdbg.h"
+
+#include "dca.h"
+#include "openvpn-plugin.h"
+
+extern struct dca *g_dca_ctx;
+
+/*
+ * __dca_route_del_msg
+ */
+static int
+__dca_route_del_msg(struct nss_ovpn_sk_route_info *route_info)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_ROUTE_DEL,  route_info);
+}
+
+/*
+ * __dca_route_status_get_msg
+ */
+static int
+__dca_route_status_get_msg(struct nss_ovpn_sk_route_info *route_info)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_ROUTE_STATE_GET,  route_info);
+}
+
+/*
+ * __dca_route_info_fill
+ */
+static int
+__dca_route_info_fill(struct mroute_addr *addr,
+                      struct nss_ovpn_sk_route_info *route_info)
+{
+  switch (addr->type & MR_ADDR_MASK)
+    {
+      case MR_ADDR_IPV4:
+        {
+          int port;
+          bool status;
+
+          if ((addr->type & MR_WITH_NETBITS) && (addr->netbits != 32))
+            return -1;
+
+          route_info->ip_version = 4;
+          memcpy(&route_info->ip_network[0], addr->addr, addr->len);
+          route_info->netmask_bits = 32;
+        }
+      break;
+
+      case MR_ADDR_IPV6:
+        {
+          if ((addr->type & MR_WITH_NETBITS) && (addr->netbits != 128))
+            return -1;
+
+          memcpy(&route_info->ip_network[0], &addr->addr, sizeof(struct in6_addr));
+          route_info->ip_version = 6;
+          route_info->netmask_bits = addr->netbits;
+        }
+      break;
+
+      default:
+          return -1;
+  }
+  return 0;
+}
+
+/*
+ * dca_route_add_msg
+ */
+int
+dca_route_add_msg(struct nss_ovpn_sk_route_info *route_info)
+{
+  return dca_send_msg(NSS_OVPN_SK_SIOC_ROUTE_ADD, route_info);
+}
+
+/*
+ * dca_routes_update
+ */
+void
+dca_routes_update(struct multi_context *m)
+{
+  struct hash_iterator hi;
+  struct hash_element *he;
+
+  if (!g_dca_ctx)
+    return;
+
+  hash_iterator_init_range(m->vhash, &hi, 0, hash_n_buckets(m->vhash));
+  while ((he = hash_iterator_next(&hi)) != NULL)
+    {
+      struct multi_route *r = (struct multi_route *) he->value;
+      struct context *c = &r->instance->context;
+      struct dca_tun *tun = c->c2.dca_ctx;
+      struct mroute_addr *addr = &r->addr;
+      struct nss_ovpn_sk_route_info route_info;
+
+      if (c->c2.context_auth != CAS_SUCCEEDED)
+        continue;
+
+      /*
+       * Check if tunnel is offloaded.
+       */
+      if (!tun)
+        continue;
+
+      if (tun->state == DCA_TUN_STATE_DOWN)
+        return;
+
+      /*
+       * Update routes which are dynamically added (ageable).
+       */
+      if (!(r->flags & MULTI_ROUTE_AGEABLE))
+        continue;
+
+      memset(&route_info, 0, sizeof(route_info));
+      route_info.tunnel_id = tun->tun.ovpn.tunnel_id;
+
+      if (__dca_route_info_fill(addr, &route_info))
+        continue;
+
+      if (!__dca_route_status_get_msg(&route_info))
+        continue;
+
+      /*
+       * Packets are transmitted and received from host in
+       * data channel offload layer, update reference.
+       */
+      r->last_reference = now;
+    }
+  hash_iterator_free(&hi);
+}
+
+/*
+ * dca_route_add
+ */
+void
+dca_route_add(struct multi_route *r)
+{
+  struct context *c = &r->instance->context;
+  struct dca_tun *tun = c->c2.dca_ctx;
+  struct mroute_addr *addr = &r->addr;
+  struct nss_ovpn_sk_route_info route_info;
+
+  if (!g_dca_ctx || !tun)
+    return;
+
+  if (!(r->flags & MULTI_ROUTE_AGEABLE))
+    return;
+
+  /*
+   * Add route.
+   */
+  memset(&route_info, 0, sizeof(route_info));
+  route_info.tunnel_id = tun->tun.ovpn.tunnel_id;
+  if (__dca_route_info_fill(addr, &route_info))
+    return;
+
+  if (!dca_route_add_msg(&route_info))
+    {
+      struct gc_arena gc = gc_new();
+      msg (D_DCA_INFO, "DCA: route added %s", mroute_addr_print_ex (addr, MAPF_IA_EMPTY_IF_UNDEF, &gc));
+      gc_free(&gc);
+    }
+}
+
+/*
+ * dca_route_del
+ */
+void
+dca_route_del(struct multi_route *r)
+{
+  struct mroute_addr *addr = &r->addr;
+  struct context *c = &r->instance->context;
+  struct dca_tun *tun = c->c2.dca_ctx;
+  struct nss_ovpn_sk_route_info route_info;
+
+  if (!g_dca_ctx || !tun)
+    return;
+
+  /*
+   * Delete route.
+   */
+  memset(&route_info, 0, sizeof(route_info));
+  route_info.tunnel_id = tun->tun.ovpn.tunnel_id;
+  if (__dca_route_info_fill(addr, &route_info))
+    return;
+
+  if (!__dca_route_del_msg(&route_info))
+    {
+      struct gc_arena gc = gc_new();
+      msg (D_DCA_INFO, "DCA: route deleted %s", mroute_addr_print_ex (addr, MAPF_IA_EMPTY_IF_UNDEF, &gc));
+      gc_free(&gc);
+    }
+}
+#else /* ifdef ENABLE_DCA */
+static void
+dummy(void)
+{
+}
+#endif /* ENABLE_DCA */
